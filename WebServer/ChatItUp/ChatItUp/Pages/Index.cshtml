@page
@model IndexModel
@inject Services.ChatService ChatService

@{
    //var recentMessages = await ChatService.GetRecentMessagesAsync();
}
@section Styles {
    <style>
        #connectionStatus {
            background-color: yellow;
            color: black;
            text-align: center;
            width: 100%;
            padding: 10px 0;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1000; /* Ensures it's above other content */
        }

        .hidden {
            display: none !important;
        }

        .visible {
            display: block !important;
        }

        .chat-container {
            display: flex;
        }

        #channelList {
            width: 20%;
            border-right: 1px solid #ddd;
            padding: 10px;
            height: 300px; /* Adjust based on your layout */
            overflow-y: auto;
        }

        #serverList {
            
            border-right: 1px solid #ddd;
            padding: 10px, 10px, 10px, 10px;
            height: 300px; /* Adjust based on your layout */
            overflow-y: auto;
        }

        #channelList {
            width: 20%;
            border-right: 1px solid #ddd;
            padding: 10px;
            height: 300px; /* Adjust based on your layout */
            overflow-y: auto;
        }

        .server, .channel {
            border: 1px solid #aaa;
            padding: 5px;
            margin-bottom: 5px;
            cursor: pointer;
        }

        .server:hover, .channel:hover {
            background-color: #f0f0f0;
        }

        .selected-server, .selected-channel {
            background-color: #ddd; /* Background color for selected server/channel */
        }

        .server img {
            padding-right: 5px;
            cursor: pointer;
            transition: transform 0.2s; /* Animation for hover effect */
        }

        .server img:hover {
            transform: scale(1.1); /* Slightly enlarges the thumbnail on hover */
        }

        #messages {
            flex-grow: 1;
            border: 1px solid #ddd;
            padding: 10px;
            margin-bottom: 20px;
            max-height: 80px;
            overflow-y: scroll;
            display: flex;
            flex-direction: column-reverse; /* Keep the scroll bar at the bottom initially */
        }


    </style>
}

<script src="~/lib/signalr/dist/browser/signalr.min.js"></script>
<!-- Modal Backdrop -->
<div id="modalBackdrop" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:1040;"></div>

<!-- Modal Content -->
<div id="modalContent" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); z-index:1050; background:white; padding:40px; border-radius:5px; border: 2px solid #000; max-width:90%; max-height:90%; overflow:auto;">
    <!-- AJAX content will be loaded here -->
</div>


<div id="connectionStatus" class="hidden">Disconnected - Attempting to reconnect...</div>

<span style="align-content:center"><input id="AudioCheckbox" type="checkbox" /> Audio</span>

<div class="chat-container">
    <div id="serverList">
        <!-- Servers will be listed here -->
        
        <!-- Add more servers as needed -->
    </div>
    <div id="channelList">
        <!-- Channels will be listed here -->
       
        <!-- Add more channels as needed -->
    </div>

    <div>
        <!-- Existing message-related elements -->
        <div id="messages"></div>
        <input type="text" id="messageInput" style="width: 80%;" />
        <button id="sendButton">Send</button>
    </div>
</div>

<script>
    var connection = new signalR.HubConnectionBuilder().withUrl("/chathub").build();
    skipCount = 0;
    const limit = 3;
    let loading = false;
    let selectedChannelId;
    let selectedServerId;
    // Receiving messages from the server
    connection.on("ReceiveMessage", function (channelid, userid, message) {
        if (channelid == selectedChannelId)
            appendMessage(userid, message, true);
    });

    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    document.body.addEventListener('click', function () {
        if (audioContext.state === 'suspended') {
            audioContext.resume();
        }
    });
    let audioQueue = [];
    let isPlaying = false;
    let isPlayingInner = false;
    let nextTime = 0; // When the next audio chunk should start playing

    // Function to process and play queued audio data
    async function processAudioQueue() {
        if (isPlaying || audioQueue.length === 0) return;
        isPlaying = true;
        if (audioContext.state === 'suspended') {
            audioContext.resume();
        }
        while (audioQueue.length > 0) {
            const audioChunkArrayBuffer = audioQueue.shift();
            try {
                await audioContext.decodeAudioData(audioChunkArrayBuffer, function (audioBuffer) {
                    const source = audioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(audioContext.destination);
                    // Schedule the source to start playing at `nextTime`
                    const now = audioContext.currentTime;
                    source.start(Math.max(nextTime, now));
                    // Update `nextTime` to schedule the next chunk
                    nextTime = Math.max(nextTime, now) + audioBuffer.duration;
                    source.onended = () => {
                        // When the audio chunk finishes playing, try to process the next one
                        isPlaying = false;
                        //processAudioQueue();
                    };
                }, (err) => console.error(err));
                
            } catch (error) {
                console.error("Error playing audio chunk:", error);
                isPlaying = false;
            }
        }
    }

    // Revised event listener to queue audio chunks
    connection.on("ReceiveAudioChunk", async base64AudioChunk => {
        console.log("Received audio");
        console.log(base64AudioChunk.substr(0, 500));
        const audioChunkArrayBuffer = Uint8Array.from(atob(base64AudioChunk), c => c.charCodeAt(0)).buffer;
        if (audioChunkArrayBuffer.byteLength > 0) {
            audioQueue.push(audioChunkArrayBuffer);
            processAudioQueue(); // Try to process the queue
        }
    });


    // Function to toggle the connection status display
    function toggleConnectionStatus(isConnected) {
        const statusDiv = document.getElementById('connectionStatus');
        if (isConnected) {
            statusDiv.classList.remove('visible');
            statusDiv.classList.add('hidden');
        } else {
            statusDiv.classList.remove('hidden');
            statusDiv.classList.add('visible');

            if (selectedChannelId) {
                selectChannel(selectedChannelId);
            }
        }
    }

    // Monitor the connection status
    connection.onclose(async () => {
        toggleConnectionStatus(false);
        attemptReconnect();
    });

    async function attemptReconnect() {
        let isConnected = false;
        while (!isConnected) {
            try {
                await connection.start();
                console.log("Reconnected to the SignalR hub successfully.");
                isConnected = true;
                toggleConnectionStatus(true);
            } catch (err) {
                console.error("Reconnection attempt failed, retrying...", err);
                // Wait for 1 or 5 seconds before trying to reconnect
                await new Promise(resolve => setTimeout(resolve, 5000)); // Adjust the timeout as needed
            }
        }
    }

    // Initially attempt to connect
    connection.start().then(function () {
        toggleConnectionStatus(true);
    }).catch(function (err) {
        console.error("Failed to connect SignalR hub on start.", err.toString());
        toggleConnectionStatus(false);
        attemptReconnect();
    });

    // Sending a message
    document.getElementById("sendButton").addEventListener("click", function (event) {
        var user = "User"; // You might want to use a more dynamic way to get the user's name
        var message = document.getElementById("messageInput").value;
        connection.invoke("SendMessage", selectedChannelId, message).catch(function (err) {
            return console.error(err.toString());
        });
        document.getElementById("messageInput").value = ''; // Clear the input after sending
        event.preventDefault();
    });

    const messagesDiv = document.getElementById('messages');

    function appendMessage(user, message, prepend = false, scroll = true) {
        const msgDiv = document.createElement("div");
        msgDiv.textContent = user + ": " + message;
        if (prepend) {
            messagesDiv.prepend(msgDiv); // Add messages to the top
            if(scroll)
                messagesDiv.scrollTop = messagesDiv.firstChild.clientHeight;
        } else {
            messagesDiv.appendChild(msgDiv); // Add messages to the bottom
            if (scroll)
                messagesDiv.scrollTop = messagesDiv.lastChild.clientHeight;
        }
    }

    async function loadMessages(initial = false) {
        if (loading) return;
        loading = true;

        const response = await fetch(`/api/chat/GetRecentMessages?channelId=${selectedChannelId}&skip=${skipCount}`);
        if (response.ok) {
            const messages = await response.json();
            messages.forEach(msg => appendMessage(msg.user, msg.body, false, skipCount == 0));
            skipCount += messages.length;
            if (messages.length > 0) {
                // Adjust scroll position only if we're not loading the initial page of messages
                //if (!initial) {
                    //messagesDiv.scrollTop = messagesDiv.firstChild.clientHeight;
                //}
            }
        } else {
            console.error('Failed to fetch messages');
        }

        loading = false;
    }

    messagesDiv.addEventListener('scroll', () => {
        isScrolledToTop = messagesDiv.scrollTop === (messagesDiv.clientHeight - messagesDiv.scrollHeight);

        // Check if scrolled to the top
        if (isScrolledToTop && !loading) {
            loadMessages();
        }
    });

    function selectChannel(channelId) {
        selectedChannelId = channelId;
        skipCount = 0; // Reset skip count for new channel
        messagesDiv.innerHTML = ''; // Clear existing messages
        
        document.querySelectorAll('.channel').forEach(channel => {
            channel.classList.remove('selected-channel');
            if (channel.dataset.channelId === channelId) {
                channel.classList.add('selected-channel');
            }
        });
        skipCount = 0;

        loadMessages(true); // Load messages for the selected channel
    }

    async function fetchChannelsForServer(serverId) {
        channels = [];
        if (loading) return;
        loading = true;

        const response = await fetch(`/api/chat/GetChannels?serverId=${serverId}`);
        if (response.ok) {
            channels = await response.json();
            updateChannelList(channels);

        } else {
            console.error('Failed to fetch messages');
        }

        loading = false;
        if (channels.length > 0)
            selectChannel(selectedChannelId? selectedChannelId : channels[0].id);
    }
        
    function updateChannelList(channels) {
        const channelListDiv = document.getElementById('channelList');
        channelListDiv.innerHTML = ''; // Clear existing channels

        channels.forEach(channel => {
            const channelDiv = document.createElement('div');
            channelDiv.className = 'channel';
            channelDiv.textContent = channel.name;
            channelDiv.setAttribute('data-channel-id', channel.id);
            channelDiv.onclick = function () { selectChannel(channel.id); };
            channelListDiv.appendChild(channelDiv);
        });
        
        
    }
    
    function selectServer(serverId) {
        if (selectedServerId != serverId) selectedChannelId = undefined;
        selectedServerId = serverId;
        document.querySelectorAll('.server').forEach(server => {
            server.classList.remove('selected-server');
            if (server.dataset.serverId === serverId) {
                server.classList.add('selected-server');
            }
        });

        // Simulate fetching channels for the selected server
        // Replace this part with an actual API call if necessary
        channels = fetchChannelsForServer(serverId);
        
    }

    async function fetchServers() {
        servers = [];
        if (loading) return;
        loading = true;

        const response = await fetch(`/api/chat/GetServers`);
        if (response.ok) {
            servers = await response.json();
            updateServerList(servers);
            
        } else {
            console.error('Failed to fetch servers');
        }

        loading = false;
        
        if(servers.length > 0)
            selectServer(selectedServerId? selectedServerId : servers[0].id);
    }

    function updateServerList(servers) {
        const serverListDiv = document.getElementById('serverList');
        serverListDiv.innerHTML = ''; // Clear existing channels

        servers.forEach(server => {
            const serverDiv = document.createElement('div');
            serverDiv.className = 'server';
            //serverDiv.textContent = server.name;
            serverDiv.setAttribute('data-server-id', server.id);

            const image = document.createElement('img');
            image.src = server.imageUrl; // Assuming server object has an `imageUrl` property
            image.alt = server.name;
            image.style.width = '64px';
            image.style.height = '64px';
            image.style.borderRadius = '50%'; // Makes the image circular
            image.title = server.name; // Tooltip

            serverDiv.appendChild(image);

            serverDiv.onclick = function () { selectServer(server.id); };
            serverListDiv.appendChild(serverDiv);
        });

        const serverDiv = document.createElement('div');
        serverDiv.className = 'server';
        //serverDiv.textContent = server.name;
        serverDiv.setAttribute('data-server-id', '*');

        const image = document.createElement('img');
        image.src = "/image/PlusSign.png"; // Assuming server object has an `imageUrl` property
        image.alt = 'Create new server';
        image.style.width = '64px';
        image.style.height = '64px';
        image.style.borderRadius = '50%'; // Makes the image circular
        image.title = 'Create new server'; // Tooltip

        serverDiv.appendChild(image);

        serverDiv.onclick = function () { showModalCreateServer(); };// window.location.href = "/CreateServer" };
        serverListDiv.appendChild(serverDiv);
       
    }
    
    async function showModalCreateServer() {
        $.ajax({
            url: "/CreateServer", // Adjust the URL as needed
            success: function (response) {
                $("#modalContent").html(response);
                $("#modalBackdrop, #modalContent").show();
                window.OnOK = function () {

                    fetchServers();
                    $("#modalBackdrop, #modalContent").hide();

                };

                window.OnCancel = function () {
                    $("#modalBackdrop, #modalContent").hide();
                };
            },
            error: function () {
                alert("Failed to load the form.");
            }
        });

    }
    fetchServers();

    let mediaRecorder = null;
    let audioChunks = [];
    let skip = 0;
    let thestream = null;
    async function ToggleAudio() {
        // Assuming your checkbox has an ID of "AudioCheckbox"
        let isChecked = document.getElementById("AudioCheckbox").checked;

        if (isChecked) {
            // Start recording
            if (mediaRecorder === null || mediaRecorder.state === "inactive") {
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => {
                        thestream = stream;
                        mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm; codecs=opus' });
                        mediaRecorder.ondataavailable = event => {
                            //audioChunks.push(event.data);
                            if (mediaRecorder.state === 'recording') {
                                // After collecting a chunk, send it immediately
                                sendAudioChunk(event.data);
                                
                            }
                        };
                        mediaRecorder.start(1000); // Split audio into chunks every 1 second
                        
                    });
            }
        } else {
            // Stop recording and send audio
            if (mediaRecorder && mediaRecorder.state !== "inactive") {
                mediaRecorder.stop();
                mediaRecorder.onstop = async () => {
                    
                    // Reset mediaRecorder to allow a new recording session
                    mediaRecorder.stream.getTracks().forEach(track => track.stop());
                    mediaRecorder = null;
                    console.log("Recording stopped and data sent");
                };
            }
        }
    }
    
    async function sendAudioChunk(chunk) {
        chunk.arrayBuffer().then(arrayBuffer => {
            const base64String = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
            console.log(base64String.substr(0, 500));
            
            // Assuming you have a SignalR connection setup as `connection`
            connection.invoke("SendAudioChunk", base64String);
        });
    }

    

    document.getElementById("AudioCheckbox").addEventListener("click", function (event) {
        ToggleAudio();
    });

</script>

